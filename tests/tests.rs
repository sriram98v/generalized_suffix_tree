use generalized_suffix_tree::suffix_tree::*;

#[test]
fn create_tree() {
    let _tree: KGST<char, String> = KGST::new('$');
}

#[test]
fn insert(){
    let mut tree: KGST<char, String> = KGST::new('$');
    let item_string:Vec<char> = "MKAILVVLLYTFTTADADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLENRHNGKLCKLRGVAPLHLGKCNIAGWILGNPECESLSTAGSWSYIVETSNPDNGTCYPGDFINYEELREQLSSVSSFEKFEIFPKTSSWPNHDTNRGVTAACPHDGAKSFYRNLLWLVKKEKENSYPMINKSYTNNKGKEVLVLWAIHHPATSADQQSLYQNANAYVFVGSSKYSKKFEPEIAARPKVRDQAGRMKYYWTLVEPGDKITFEATGNLVVPIYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFNHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDTCMESVKNGTYDYPKYSEEAKLNREEIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".chars().collect();
    let item_id:String = "World".to_string();
    tree.insert(item_id.clone(), item_string.clone(),&0);
    for string_idx in 0..item_string.len()-1{
        let suffix_match = tree.suffix_match(&item_string[string_idx..]);
        assert!(suffix_match.get(&item_id).expect("suffix not found!").contains(&string_idx));
    }
}

#[test]
fn insert_set(){
    let mut tree: KGST<char, String> = KGST::new('$');
    let string_set: Vec<Vec<char>> = vec![
        "MKAILVVLLYTFTTADADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLENRHNGKLCKLRGVAPLHLGKCNIAGWILGNPECESLSTAGSWSYIVETSNPDNGTCYPGDFINYEELREQLSSVSSFEKFEIFPKTSSWPNHDTNRGVTAACPHDGAKSFYRNLLWLVKKEKENSYPMINKSYTNNKGKEVLVLWAIHHPATSADQQSLYQNANAYVFVGSSKYSKKFEPEIAARPKVRDQAGRMKYYWTLVEPGDKITFEATGNLVVPIYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFNHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDTCMESVKNGTYDYPKYSEEAKLNREEIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
        "MKAILVVLLYTFTTANADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLEDKHNGKLCKLRGVAPLHLGKCNIAGWILGNPECESLSTARSWSYIVETSNSDNGTCYPGDFINYEELREQLSSVSSFERFEIFPKTSSWPNHDSNKGVTAACPHAGAKSFYKNLVWLVKKEKENSYPKLNKTYINDKGKEVLVLWGIHHPPTTADQQSLYQNADAYVFVGTSRYSKKFKPEIAKRPKVRDQEGRMNYYWTLVEPGDKITFEATGNLVVPRYAFTMERNAGSGIIISDTPVHDCNTTCQTPEGAINTSLPFQNVHPITIGKCPKYVKSTKLRLATGLRNVPSIQSRGLFGAIAGFIEGGWTGMVDGWYGYHHQNEQGSGYAADLKSTQNAIDEITNKVNSVIEKMNTQFTAVGKEFNHLEKRIENLNKKVDDGFLDIWTYNAXLLVLLENERTLDYHDSNVKNLYEKVRTQLKNNAKEIGNGCFEFYHKCDNTCMESVKNGTYDYPKYSEEAKLNREKIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
        "MKAIIVVVLLYTFTTANADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLKNRHNGKLCKLRGVAPLHLGKCNIAGWLLGNPECEPLSTASSWAYIVETSNSDNGTCYPGDFINYEELTEHLSSVSSFERFEIFPKTNSWPNHDTNKGVTAACPHAGTNSFYRNGIWLVKKENIYPKKSKSYKNKKKKEVLVLWAIHHPSTSADQQSLYQNADAYVFVGSSRYSRKFEPEIATRPKVRDQAGRMNYYWTLVEPGDKITFEATGNLVAPRYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFSHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDMCMESVKNGTYDYPKYSEEAKLNREEIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
        "MKAIIVVYLLHLQTATYADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLENRHNGKLCKLRGVAPLHLGKCNIAGWLLGNPECESLSTASSWSYIVETSNSDNGTCYPGDFINYEELREQLSSVSSFERFEIFPKTSSWPNHDTNRGVTAACPHAGTNSFYRNLVWLVKKGNSYPKINKSYINNKEKEVLVLWAIHHPSTSADQQSLYQNADAYVFVGSSRYSKKFEPEIATRPKVRDQAGRMNYYWTLVEPGDKITFEATGNLVAPRYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFSHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDMCMESVKNGTYDYPKYSEEAKLNREGIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
    ];
    for (item_idx, item) in string_set.iter().enumerate(){
        tree.insert(item_idx.to_string(), item.clone(), &0);
    }
    for (item_idx, item) in string_set.iter().enumerate(){
            for string_idx in 0..string_set[item_idx].len()-1{
            let suffix_match = tree.suffix_match(&item[string_idx..]);
            assert!(suffix_match.get(&item_idx.to_string()).expect("suffix not found!").contains(&string_idx));
        }
    }
}

// #[test]
// fn serialize_deserialize_tree(){
//     let mut tree: KGST<char, String> = KGST::new('$');
//     let item_string:Vec<char> = "GATTACAGATTACAXYZGATTACAGATTACA".chars().collect();
//     let item_id:String = "World".to_string();
//     tree.insert(item_id.clone(), item_string.clone(), &0);
//     let serialized = serde_json::to_string(&tree).unwrap();
//     let tree_2: KGST<char, String> = serde_json::from_str(&serialized).unwrap();
//     assert_eq!(tree.get_nodes(), tree_2.get_nodes());
// }

#[test]
fn preorder_nodes(){
    let mut tree: KGST<char, String> = KGST::new('$');
    let item_string:Vec<char> = "abcabxabcd".chars().collect();
    let item_id:String = "World".to_string();
    tree.insert(item_id.clone(), item_string.clone(), &0);
    assert_eq!(tree.iter_nodes_pre().collect::<Vec<usize>>(), vec![0, 16, 15, 13, 14, 3, 8, 6, 11, 12, 2, 7, 4, 9, 10, 1, 5]);
}

#[test]
fn postorder_nodes(){
    let mut tree: KGST<char, String> = KGST::new('$');
    let item_string:Vec<char> = "abcabxabcd".chars().collect();
    let item_id:String = "World".to_string();
    tree.insert(item_id.clone(), item_string.clone(), &0);
    let node_post = tree.iter_nodes_post();
    assert_eq!(node_post.collect::<Vec<usize>>(), vec![16, 15, 14, 3, 13, 8, 12, 2, 11, 7, 6, 10, 1, 9, 5, 4, 0]);
}

// #[test]
// fn postorder_edges(){
//     let mut tree: KGST<char, String> = KGST::new('$');
//     let item_string:Vec<char> = "abcabxabcd".chars().collect();
//     let item_id:String = "World".to_string();
//     tree.insert(item_id.clone(), item_string.clone(), &0);
//     let edge_post = tree.iter_edges_post();
//     dbg!(edge_post.collect::<Vec<(usize, usize)>>());
// }

#[test]
fn node_paths(){
    let mut tree: KGST<char, String> = KGST::new('$');
    let item_string:Vec<char> = "abcabxabcd".chars().collect();
    let item_id:String = "World".to_string();
    tree.insert(item_id.clone(), item_string.clone(), &0);
    let edge_post = tree.iter_path_pre(&12);
    dbg!(edge_post.collect::<Vec<usize>>());
}

// #[test]
// fn export_all_nodes(){
//     let mut tree: KGST<char, String> = KGST::new('$');
//     let string_set: Vec<Vec<char>> = vec![
//         "MKAILVVLLYTFTTADADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLENRHNGKLCKLRGVAPLHLGKCNIAGWILGNPECESLSTAGSWSYIVETSNPDNGTCYPGDFINYEELREQLSSVSSFEKFEIFPKTSSWPNHDTNRGVTAACPHDGAKSFYRNLLWLVKKEKENSYPMINKSYTNNKGKEVLVLWAIHHPATSADQQSLYQNANAYVFVGSSKYSKKFEPEIAARPKVRDQAGRMKYYWTLVEPGDKITFEATGNLVVPIYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFNHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDTCMESVKNGTYDYPKYSEEAKLNREEIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
//         "MKAILVVLLYTFTTANADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLEDKHNGKLCKLRGVAPLHLGKCNIAGWILGNPECESLSTARSWSYIVETSNSDNGTCYPGDFINYEELREQLSSVSSFERFEIFPKTSSWPNHDSNKGVTAACPHAGAKSFYKNLVWLVKKEKENSYPKLNKTYINDKGKEVLVLWGIHHPPTTADQQSLYQNADAYVFVGTSRYSKKFKPEIAKRPKVRDQEGRMNYYWTLVEPGDKITFEATGNLVVPRYAFTMERNAGSGIIISDTPVHDCNTTCQTPEGAINTSLPFQNVHPITIGKCPKYVKSTKLRLATGLRNVPSIQSRGLFGAIAGFIEGGWTGMVDGWYGYHHQNEQGSGYAADLKSTQNAIDEITNKVNSVIEKMNTQFTAVGKEFNHLEKRIENLNKKVDDGFLDIWTYNAXLLVLLENERTLDYHDSNVKNLYEKVRTQLKNNAKEIGNGCFEFYHKCDNTCMESVKNGTYDYPKYSEEAKLNREKIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
//         "MKAIIVVVLLYTFTTANADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLKNRHNGKLCKLRGVAPLHLGKCNIAGWLLGNPECEPLSTASSWAYIVETSNSDNGTCYPGDFINYEELTEHLSSVSSFERFEIFPKTNSWPNHDTNKGVTAACPHAGTNSFYRNGIWLVKKENIYPKKSKSYKNKKKKEVLVLWAIHHPSTSADQQSLYQNADAYVFVGSSRYSRKFEPEIATRPKVRDQAGRMNYYWTLVEPGDKITFEATGNLVAPRYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFSHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDMCMESVKNGTYDYPKYSEEAKLNREEIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
//         "MKAIIVVYLLHLQTATYADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLENRHNGKLCKLRGVAPLHLGKCNIAGWLLGNPECESLSTASSWSYIVETSNSDNGTCYPGDFINYEELREQLSSVSSFERFEIFPKTSSWPNHDTNRGVTAACPHAGTNSFYRNLVWLVKKGNSYPKINKSYINNKEKEVLVLWAIHHPSTSADQQSLYQNADAYVFVGSSRYSKKFEPEIATRPKVRDQAGRMNYYWTLVEPGDKITFEATGNLVAPRYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFSHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDMCMESVKNGTYDYPKYSEEAKLNREGIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
//     ];
//     for item_idx in 0..string_set.len(){
//         tree.insert(item_idx.to_string(), string_set[item_idx].clone(), &0);
//     }
//     let nodes = tree.export_all_nodes();
//     serde_json::to_string_pretty(&nodes).expect("error in node vec");
// }


#[test]
fn insert_trunc(){
    let mut tree: KGST<char, String> = KGST::new('$');
    let item_string:Vec<char> = "MKAILVVLLYTFTTADADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLENRHNGKLCKLRGVAPLHLGKCNIAGWILGNPECESLSTAGSWSYIVETSNPDNGTCYPGDFINYEELREQLSSVSSFEKFEIFPKTSSWPNHDTNRGVTAACPHDGAKSFYRNLLWLVKKEKENSYPMINKSYTNNKGKEVLVLWAIHHPATSADQQSLYQNANAYVFVGSSKYSKKFEPEIAARPKVRDQAGRMKYYWTLVEPGDKITFEATGNLVVPIYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFNHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDTCMESVKNGTYDYPKYSEEAKLNREEIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".chars().collect();
    let item_id:String = "World".to_string();
    let max_depth: usize = 3;
    tree.insert(item_id.clone(), item_string.clone(), &max_depth);
    for i in 0..item_string.len()-max_depth{
        let substring_match = tree.substring_match(&item_string[i..i+max_depth]);
        assert!(substring_match.get(&item_id).expect("substring not found!").contains(&i));
    }
    for i in 0..item_string.len()-max_depth{
        let substring_match = tree.substring_match(&item_string[i..i+max_depth+1]);
        assert_eq!(substring_match.get(&item_id), None);
    }
}

#[test]
fn insert_set_trunc(){
    let mut tree: KGST<char, String> = KGST::new('$');
    let string_set: Vec<Vec<char>> = vec![
        "MKAILVVLLYTFTTADADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLENRHNGKLCKLRGVAPLHLGKCNIAGWILGNPECESLSTAGSWSYIVETSNPDNGTCYPGDFINYEELREQLSSVSSFEKFEIFPKTSSWPNHDTNRGVTAACPHDGAKSFYRNLLWLVKKEKENSYPMINKSYTNNKGKEVLVLWAIHHPATSADQQSLYQNANAYVFVGSSKYSKKFEPEIAARPKVRDQAGRMKYYWTLVEPGDKITFEATGNLVVPIYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFNHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDTCMESVKNGTYDYPKYSEEAKLNREEIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
        "MKAILVVLLYTFTTANADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLEDKHNGKLCKLRGVAPLHLGKCNIAGWILGNPECESLSTARSWSYIVETSNSDNGTCYPGDFINYEELREQLSSVSSFERFEIFPKTSSWPNHDSNKGVTAACPHAGAKSFYKNLVWLVKKEKENSYPKLNKTYINDKGKEVLVLWGIHHPPTTADQQSLYQNADAYVFVGTSRYSKKFKPEIAKRPKVRDQEGRMNYYWTLVEPGDKITFEATGNLVVPRYAFTMERNAGSGIIISDTPVHDCNTTCQTPEGAINTSLPFQNVHPITIGKCPKYVKSTKLRLATGLRNVPSIQSRGLFGAIAGFIEGGWTGMVDGWYGYHHQNEQGSGYAADLKSTQNAIDEITNKVNSVIEKMNTQFTAVGKEFNHLEKRIENLNKKVDDGFLDIWTYNAXLLVLLENERTLDYHDSNVKNLYEKVRTQLKNNAKEIGNGCFEFYHKCDNTCMESVKNGTYDYPKYSEEAKLNREKIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
        "MKAIIVVVLLYTFTTANADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLKNRHNGKLCKLRGVAPLHLGKCNIAGWLLGNPECEPLSTASSWAYIVETSNSDNGTCYPGDFINYEELTEHLSSVSSFERFEIFPKTNSWPNHDTNKGVTAACPHAGTNSFYRNGIWLVKKENIYPKKSKSYKNKKKKEVLVLWAIHHPSTSADQQSLYQNADAYVFVGSSRYSRKFEPEIATRPKVRDQAGRMNYYWTLVEPGDKITFEATGNLVAPRYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFSHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDMCMESVKNGTYDYPKYSEEAKLNREEIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
        "MKAIIVVYLLHLQTATYADTLCIGYHANNSTDTVDTVLEKNVTVTHSVNLLENRHNGKLCKLRGVAPLHLGKCNIAGWLLGNPECESLSTASSWSYIVETSNSDNGTCYPGDFINYEELREQLSSVSSFERFEIFPKTSSWPNHDTNRGVTAACPHAGTNSFYRNLVWLVKKGNSYPKINKSYINNKEKEVLVLWAIHHPSTSADQQSLYQNADAYVFVGSSRYSKKFEPEIATRPKVRDQAGRMNYYWTLVEPGDKITFEATGNLVAPRYAFALKRNSGSGIIISDTSVHDCDTTCQTPNGAINTSLPFQNIHPVTIGECPKYVKSTKLRMATGLRNIPSIQSRGLFGAIAGFIEGGWTGMIDGWYGYHHQNEQGSGYAADLKSTQNAIDGITNKVNSVIEKMNTQFTAVGKEFSHLERRIENLNKKVDDGFLDIWTYNAELLVLLENERTLDYHDSNVKNLYEKVRSQLKNNAKEIGNGCFEFYHKCDDMCMESVKNGTYDYPKYSEEAKLNREGIDGVKLESTRIYQILAIYSTVASSLVLVVSLGAISFWMCSNGSLQCRICI".to_string().chars().collect(), 
    ];
    let max_depth: usize = 3;
    for (item_idx, item) in string_set.iter().enumerate(){
        tree.insert(item_idx.to_string(), item.clone(), &max_depth);
    }
    for (item_idx, item) in string_set.iter().enumerate(){
        for string_idx in 0..string_set[item_idx].len()-max_depth{
            let substring_match = tree.substring_match(&item[string_idx..string_idx+max_depth]);
            assert!(substring_match.get(&item_idx.to_string()).expect("suffix not found!").contains(&string_idx));
        }
        for string_idx in 0..string_set[item_idx].len()-max_depth{
            let substring_match = tree.substring_match(&item[string_idx..string_idx+max_depth+1]);
            assert_eq!(substring_match.get(&item_idx.to_string()), None);
        }
    }
}

// #[test]
// fn insert_set_var_trunc(){
//     let mut tree: KGST<char, String> = KGST::new('$');
//     let string_set: Vec<Vec<char>> = vec!["GATTACAGATTACAXYZGATTACAGATTACA".to_string().chars().collect(), "CXYZTTATAGCXYZCGTACAGACCGAA".to_string().chars().collect()];
//     let id_set:Vec<String> = vec!["first".to_string(),"second".to_string()];
//     let max_depth: Vec<usize> = vec![3, 5];
//     for i in 0..string_set.len(){
//         tree.insert(id_set[i].clone(), string_set[i].clone(), &max_depth[i]);
//     }

//     for item_idx in 0..string_set.len(){
//         for string_idx in 0..string_set[item_idx].len()-max_depth[item_idx]{
//             let substring_match = tree.substring_match(&string_set[item_idx][string_idx..string_idx+max_depth[item_idx]]);
//             assert!(substring_match.get(&id_set[item_idx]).expect("Substring not found!").contains(&string_idx));
//         }
//     }

//     let mut tree: KGST<char, String> = KGST::new('$');
//     let string_set: Vec<Vec<char>> = vec!["GATTACAGATTACAXYZGATTACAGATTACA".to_string().chars().collect(), "CXYZTTATAGCXYZCGTACAGACCGAA".to_string().chars().collect()];
//     let id_set:Vec<String> = vec!["first".to_string(),"second".to_string()];
//     let max_depth: Vec<usize> = vec![5, 3];
//     for i in 0..string_set.len(){
//         tree.insert(id_set[i].clone(), string_set[i].clone(), &max_depth[i]);
//     }
//     for item_idx in 0..string_set.len(){
//         for string_idx in 0..string_set[item_idx].len()-max_depth[item_idx]{
//             let substring_match = tree.substring_match(&string_set[item_idx][string_idx..string_idx+max_depth[item_idx]]);
//             assert!(substring_match.get(&id_set[item_idx]).expect("Substring not found!").contains(&string_idx));
//         }
//     }
// }